## Практическое задание

Закрепите полученные знания, выполнив практическую работу. Оба задания обязательны для выполнения и сдачи на проверку.

### Цель практической работы

**Научиться:**
- работать со стандартными функциональными интерфейсами, применять лямбда-выражения;
- создавать свои собственные реализации функциональных интерфейсов и методов Stream API — интерфейса Collection.

### Что нужно сделать

Для выполнения этого задания используйте проект из практической работы 12.1, в GitLab — директория **Functions**. 

В видео были рассмотрены основные функциональные интерфейсы, которые есть в Java. 
Чаще всего из них применяются Function<T, R>, BiFunction<T, U, R>  и Predicate<T>.

Подробнее — в документации Oracle:
- [Predicate (Java SE 11 & JDK 11 )](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Predicate.html)
- [Function (Java SE 11 & JDK 11 )](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/Function.html)
- [BiFunction (Java SE 11 & JDK 11 )](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/function/BiFunction.html)

Необходимо создать следующие абстрактные классы/интерфейсы:
- **Function1** — функция одного аргумента (**f(x)**);
- **Function2** — функция от двух аргументов (**f(x, y))**;
- **Predicate** — предикат для одного аргумента.

Подумайте, как лучше применить наследование, чтобы выстроить из них иерархию.

В рамках этих абстрактных классов/интерфейсов нужно создать:
- `Function1.compose` — композиция: принимает `Function1 g`, возвращает `g(f(x))`;
- `Function2.compose` — композиция: принимает `Function1 g`, возвращает `g(f(x, y))`;
- `Function2.bind1` — bind первого аргумента: принимает первый аргумент, возвращает `f(_, y)`;
- `Function2.bind2` — bind второго аргумента: принимает второй аргумент, возвращает `f(x, _)`;
- `Predicate.or/Predicate.and`: принимают один предикат в качестве аргумента, возвращают предикат, который ведёт себя [так](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%B0), 
как дизъюнкция/конъюнкция текущего предиката и предиката-аргумента; семантика ленивая, как у || и &&;
- Predicate.not принимает ноль аргументов, возвращает предикат-отрицание текущего предиката;
- Константные предикаты: `Predicate.ALWAYS_TRUE`, `Predicate.ALWAYS_FALSE`.

**В итоге:** созданы абстрактные классы/интерфейсы в соответствии с заданием, в них реализован необходимый набор методов.

Методы Stream API являются функциями высшего порядка, то есть принимают в качестве аргумента или возвращают другую функцию.

По аналогии со Stream API предлагается создать свою упрощённую реализацию класса для работы с коллекциями с использованием созданных ранее функциональных интерфейсов **Function1**, **Function2** и **Predicate**.

Необходимо создать класс **Collections** со следующими статическими методами, оперирующими **Iterable**, **Function1**, **Function2** и **Predicate**:
- `map` — принимает `f` и `a`, применяет `f` к каждому элементу `a_i` и возвращает список `[f(a_1), ..., f(a_n)]`;
- `filter` — принимает `p` и `a`, возвращает список, содержащий элементы a_i, на которых `p(a_i) == true`;
- `takeWhile` — принимает `p` и `a`, возвращает список с началом a до первого элемента a_i, для которого `p(a_i) == false`;
- `takeUnless` — то же, что и `takeWhile`, только для `p(a_i) == true`;
- `foldr` / `foldl` — принимает функцию двух аргументов, начальное значение и коллекцию, работает так.

При выполнении задания будут полезны следующие ссылки на документацию:
- [Lesson: Generics (The Java™ Tutorials > Bonus)](https://docs.oracle.com/javase/tutorial/extra/generics/index.html)
- [Wildcards (The Java™ Tutorials > Bonus > Generics)](https://docs.oracle.com/javase/tutorial/extra/generics/wildcards.html)
- [Generic Methods - Java™ Tutorials](https://docs.oracle.com/javase/tutorial/extra/generics/methods.html)

Также рекомендуем повторить модули 10 и 11 (Generics и Collections).

### Критерии оценки задания

**Принято:**

- Выполнены все указанные в задании требования: созданы реализации Function1, Function2 и Predicate и утилитного класса Collections .
- Все методы работают без ошибок, код компилируется.

**На доработку:** задание не выполнено, выполнено неточно или частично.

### Как отправить работу на проверку

Сдайте практическую работу этого модуля через систему контроля версий Git сервиса Skillbox GitLab. 
В нижнем поле практической работы напишите «Сделано» и прикрепите ссылку на репозиторий. Ссылки на реплит оставлять не нужно.